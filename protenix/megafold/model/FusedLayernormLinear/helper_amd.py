# Autotuned configs for AMD MI250 gpus  

DEFAULT_CONFIG = (16, 16, 16, 8, 1, 8, 255) 

common_inputs = {    
    # SMALL INPUTS: 
    # (384, 128, 384): ((32, 32, 32, 4, 2, 4, 128), (128, 16, 32, 4, 4, 8, 168)),    
    # (384, 512, 64): ((64, 64, 16, 4, 2, 4, 168), (16, 16, 32, 4, 4, 8, 96)),    
    # (768, 512, 64): ((64, 64, 16, 4, 2, 4, 255), (32, 16, 32, 4, 4, 8, 96)),
    # (384, 384, 384): ((32, 64, 16, 8, 4, 4, 255), (128, 16, 32, 8, 4, 8, 196)),

    # (384, 128, 768): ((32, 32, 32, 4, 4, 4, 255), (128, 16, 32, 4, 4, 8, 96)),
    # (1536, 128, 768): ((32, 64, 16, 4, 2, 4, 168), (128, 32, 32, 4, 4, 4, 196)),
    
    # (384, 128, 801): ((32, 64, 32, 4, 2, 8, 168), (128, 16, 32, 4, 4, 8, 96)),
    # (1536, 128, 801): ((32, 64, 32, 4, 2, 8, 168), (128, 32, 32, 4, 4, 4, 196)),
    
    # (384, 768, 801): ((32, 64, 16, 4, 4, 4, 255), (128, 16, 32, 4, 4, 8, 128)),
    # (1536, 768, 801): ((64, 128, 16, 8, 2, 8, 128), (128, 32, 32, 4, 4, 4, 128)),
    
    # (384, 64, 64): ((32, 32, 32, 4, 4, 4, 128), (16, 16, 32, 4, 4, 8, 96)),
    # (768, 64, 64): ((32, 32, 32, 4, 2, 4, 168), (32, 16, 32, 4, 4, 8, 96)),
    # (1536, 64, 64): ((32, 32, 32, 8, 2, 4, 96), (64, 16, 32, 8, 4, 8, 196)),
    # (6144, 64, 64): ((64, 64, 32, 4, 4, 4, 168), (128, 16, 32, 8, 4, 8, 128)),
    
    # (250, 1536, 801): ((32, 64, 32, 4, 2, 8, 96), (128, 16, 32, 4, 4, 8, 96)),
    # (500, 1536, 801): ((64, 64, 32, 4, 2, 8, 96), (128, 16, 32, 4, 4, 8, 128)),
    # (750, 1536, 801): ((32, 64, 16, 4, 2, 4, 128), (128, 16, 32, 4, 4, 4, 168)),
    # (1000, 1536, 801): ((32, 256, 32, 8, 2, 8, 128), (128, 32, 32, 4, 4, 8, 196)),
    # (1250, 1536, 801): ((32, 128, 16, 4, 4, 4, 96), (128, 16, 32, 4, 2, 4, 96)),
    # (1536, 1536, 801): ((64, 256, 32, 8, 2, 8, 128), (128, 32, 32, 4, 4, 4, 128)),

    ### LARGE INPUTS: 
    (147456, 8, 128): ((256, 32, 32, 4, 2, 8, 3), (128, 32, 16, 4, 2, 4, 3)),  
    (147456, 16, 128): ((128, 32, 32, 1, 2, 4, 3), (128, 32, 16, 4, 2, 4, 3)),  
    (147456, 64, 128): ((64, 64, 32, 1, 2, 4, 3), (256, 32, 16, 8, 2, 8, 2)),
    
    (147456, 128, 128): ((64, 128, 32, 1, 2, 4, 2), (256, 32, 16, 8, 2, 4, 2)),  
    (147456, 64, 64): ((64, 64, 32, 1, 3, 4, 2), (256, 32, 16, 8, 2, 4, 2)),
    (589824, 64, 64): ((64, 64, 32, 8, 3, 4, 2), (256, 32, 16, 1, 2, 4, 2)), 
    
    (147456, 512, 64): ((128, 256, 16, 1, 3, 4, 2), (256, 32, 16, 1, 2, 4, 2)), 
    (147456, 512, 128): ((64, 256, 16, 8, 2, 4, 3), (256, 32, 16, 1, 2, 4, 2)), 
    (147456, 1024, 128): ((64, 256, 16, 8, 2, 4, 3), (256, 32, 32, 4, 3, 4, 2)), 
    
    # trianglemult
    (147456, 516, 64): ((128, 128, 32, 1, 3, 4, 2), (128, 32, 32, 8, 4, 4, 3)),
    
    (147456, 320, 64): ((64, 128, 32, 8, 3, 4, 3), (256, 32, 16, 1, 2, 4, 2)), 
    (147456, 640, 128): ((64, 256, 16, 8, 2, 4, 2), (256, 32, 32, 4, 3, 4, 2)), 
}

# Structured (N, K) map logic  # (N, K) -> [m_list]
m_list_for_nk = {
    ### LARGE INPUTS:
    # n^2: 
    (8, 128): [60000, 100000, 147456],
    (64, 128): [60000, 100000, 147456],
    (128, 128): [60000, 100000, 147456],
    (64, 64): [60000, 100000, 147456, 589824], 
    
    (512, 64): [60000, 100000, 147456],
    (512, 128): [60000, 100000, 147456],
    (1024, 128): [60000, 100000, 120000, 147456],
    
    (516, 64): [60000, 100000, 147456],
    (320, 64): [60000, 100000, 147456],
    (640, 128): [60000, 100000, 147456],
    
    # second shape of pairwise_repr, 27 * 54 * (40, 55, 70, 85, 95, 109, 120, 130) varies a lot 
    (16, 128): [60000, 120000, 147456, 200000], # [60000, 100000, 120000, 147456, 189540, 200000, 233280, 320760, 408240,       495720, 554040, 635688, 699840, 758160],
    (4, 16): [58320, 102060, 138510, 189540] #, 233280, 320760, 408240,   495720, 554040, 635688, 699840, 758160], 
}


structured_maps = {    
    ### LARGE INPUTS:
    (60000, 8, 128): ((128, 32, 32, 8, 2, 4, 2), (256, 32, 16, 8, 4, 4, 2)),
    (100000, 8, 128): ((128, 32, 32, 8, 2, 4, 2), (256, 32, 16, 8, 3, 4, 2)),
    (147456, 8, 128): ((256, 32, 32, 4, 2, 8, 3), (128, 32, 16, 4, 2, 4, 3)),  

    (60000, 64, 128): ((64, 64, 32, 4, 2, 4, 2), (256, 32, 16, 4, 2, 4, 2)),
    (100000, 64, 128): ((64, 64, 32, 8, 2, 4, 2), (256, 32, 16, 8, 2, 4, 2)),
    (147456, 64, 128): ((64, 64, 32, 1, 2, 4, 3), (256, 32, 16, 8, 2, 8, 2)),

    (60000, 128, 128): ((64, 128, 32, 8, 2, 4, 2), (256, 32, 16, 8, 2, 4, 2)),
    (100000, 128, 128): ((64, 128, 32, 1, 2, 4, 3), (256, 32, 16, 8, 2, 4, 2)),
    (147456, 128, 128): ((64, 128, 32, 1, 2, 4, 2), (256, 32, 16, 8, 2, 4, 2)),  
    
    (60000, 64, 64): ((64, 64, 32, 1, 3, 4, 2), (256, 32, 16, 8, 2, 4, 2)), 
    (100000, 64, 64): ((64, 64, 32, 1, 3, 4, 3), (256, 32, 16, 4, 2, 4, 2)), 
    (147456, 64, 64): ((64, 64, 32, 1, 3, 4, 2), (256, 32, 16, 8, 2, 4, 2)),
    (589824, 64, 64): ((64, 64, 32, 8, 3, 4, 2), (256, 32, 16, 1, 2, 4, 2)), 
    
    (60000, 512, 64): ((64, 256, 16, 8, 2, 4, 2), (128, 64, 16, 1, 2, 4, 2)),
    (100000, 512, 64): ((128, 256, 16, 1, 3, 4, 2), (256, 32, 16, 1, 2, 4, 2)),
    (147456, 512, 64): ((128, 256, 16, 1, 3, 4, 2), (256, 32, 16, 1, 2, 4, 2)), 

    (60000, 512, 128): ((64, 256, 16, 8, 2, 4, 2), (128, 64, 16, 1, 2, 4, 2)),
    (100000, 512, 128): ((64, 256, 16, 8, 2, 4, 2), (256, 32, 16, 1, 2, 4, 2)),
    (147456, 512, 128): ((64, 256, 16, 8, 2, 4, 3), (256, 32, 16, 1, 2, 4, 2)), 
    
    (60000, 1024, 128): ((64, 256, 16, 8, 2, 4, 2), (256, 32, 32, 4, 3, 4, 2)),
    (80000, 1024, 128): ((64, 256, 16, 8, 2, 4, 2), (256, 32, 32, 4, 3, 4, 2)),
    (100000, 1024, 128): ((64, 256, 16, 8, 2, 4, 2), (256, 32, 32, 4, 3, 4, 2)),
    (120000, 1024, 128): ((64, 256, 16, 8, 2, 4, 2), (256, 32, 32, 4, 3, 4, 2)),
    (147456, 1024, 128): ((64, 256, 16, 8, 2, 4, 3), (256, 32, 32, 4, 3, 4, 2)), 
    
    (60000, 516, 64): ((128, 128, 32, 1, 3, 4, 2), (128, 32, 32, 8, 4, 4, 3)), 
    (100000, 516, 64): ((128, 128, 32, 4, 3, 4, 2), (128, 32, 32, 8, 2, 4, 3)), 
    (147456, 516, 64): ((128, 128, 32, 1, 3, 4, 2), (128, 32, 32, 8, 4, 4, 3)),
    
    (60000, 320, 64): ((64, 128, 32, 8, 3, 4, 3), (256, 32, 16, 1, 2, 4, 2)),
    (100000, 320, 64): ((64, 128, 32, 8, 3, 4, 2), (256, 32, 16, 1, 2, 4, 2)),
    (147456, 320, 64): ((64, 128, 32, 8, 3, 4, 3), (256, 32, 16, 1, 2, 4, 2)), 

    (60000, 640, 128): ((64, 256, 16, 8, 2, 4, 2), (128, 64, 16, 1, 2, 4, 2)),
    (100000, 640, 128): ((64, 256, 16, 8, 2, 4, 2), (256, 32, 32, 1, 3, 4, 2)),
    (147456, 640, 128): ((64, 256, 16, 8, 2, 4, 2), (256, 32, 32, 4, 3, 4, 2)), 

    (60000, 16, 128): ((128, 32, 32, 4, 2, 4, 3), (128, 16, 16, 8, 2, 4, 3)),
    (120000, 16, 128): ((64, 64, 32, 4, 2, 4, 3), (128, 16, 16, 4, 2, 4, 3)),
    (147456, 16, 128): ((128, 32, 32, 1, 2, 4, 3), (128, 32, 16, 4, 2, 4, 3)),  
    (200000, 16, 128): ((128, 32, 32, 4, 2, 4, 3), (128, 16, 16, 8, 2, 4, 3)),
    
    (58320, 4, 16): ((128, 32, 16, 1, 2, 4, 3), (256, 32, 16, 4, 3, 8, 2)), 
    (102060, 4, 16): ((256, 32, 16, 1, 2, 4, 2), (256, 32, 16, 8, 4, 8, 3)), 
    (138510, 4, 16): ((128, 32, 16, 4, 2, 4, 2), (256, 32, 16, 1, 4, 8, 2)),
    (189540, 4, 16): ((256, 32, 16, 4, 2, 4, 3), (256, 32, 16, 1, 3, 4, 2)),
    # (233280, 4, 16): ((128, 32, 16, 4, 2, 4, 96), (128, 16, 16, 8, 4, 4, 128)), 
    # (320760, 4, 16): ((128, 32, 16, 4, 2, 4, 96), (128, 16, 16, 8, 2, 4, 128)), 
    # (408240, 4, 16): ((128, 32, 16, 4, 4, 4, 96), (128, 16, 16, 4, 4, 4, 128)), 
    # (495720, 4, 16): ((128, 32, 16, 4, 2, 4, 96), (128, 16, 16, 4, 4, 4, 128)),
    # (554040, 4, 16): ((128, 32, 16, 8, 4, 4, 96), (128, 16, 16, 4, 2, 4, 128)),
    # (635688, 4, 16): ((64, 32, 16, 4, 2, 4, 168), (128, 16, 16, 4, 2, 4, 128)),
    # (699840, 4, 16): ((128, 32, 16, 8, 4, 4, 96), (128, 16, 16, 8, 2, 4, 128)),
    # (758160, 4, 16): ((128, 32, 16, 4, 2, 4, 96), (128, 16, 16, 4, 2, 4, 128)),
}

def calculate_config_layernorm_linear(M, N, K, mode):
    """
    Return optimal config for input sizes: BLOCK_SIZE_M, BLOCK_SIZE_N, BLOCK_SIZE_K, GROUP_SIZE_M, num_stages, num_warps, maxnreg
    
    mode: 0=fwd; 1=bwd; 2=fwd+bwd
    """
    res = common_inputs.get((M, N, K), None)
    if res is not None:
        return res[mode] if mode < 2 else res 
    
    m_list = m_list_for_nk.get((N, K), None)
    
    # handle (n, k) not exist 
    if m_list is None:
        return None
    
    closest_m = get_closest(M, m_list)
    
    # M not supported in m_list 
    if closest_m is None:
        return None
    
    res = structured_maps[(closest_m, N, K)]
    return res[mode] if mode < 2 else res 
    

def get_closest(length, choices):    
    LOWER_MARGIN = 0.15 # if not covered by choices 
    if length < choices[0] * (1-LOWER_MARGIN):
        return None 
    
    if length > choices[-1]:
        return choices[-1]

    # Initialize pointers for binary search
    left, right = 0, len(choices) - 1

    # Perform binary search to find the closest value
    while left < right:
        mid = (left + right) // 2
        if choices[mid] < length:
            left = mid + 1
        else:
            right = mid

    # After the loop, left == right, and we need to check the closest between choices[left] and choices[left - 1]
    if left == 0:
        return choices[left]
    if left == len(choices):
        return choices[-1]
    if abs(choices[left] - length) < abs(choices[left - 1] - length):
        return choices[left]
    else:
        return choices[left - 1]